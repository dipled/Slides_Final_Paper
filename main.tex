\documentclass[xcolor=table]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[alf]{abntex2cite}
\usepackage{udesc}
\usepackage{amsfonts,amsmath,amssymb,mathtools}
\usepackage{verbatim}
\usepackage{listings}
\usepackage[ddmmyyyy]{datetime}
\usepackage{hyperref, url}
% \usepackage{titlepic}
\usepackage{graphicx}
\usepackage{bussproofs}
\usepackage{multirow}
\usepackage{changepage}
\usepackage{xspace}
\usepackage{bm}
\usepackage{xfrac}
\usepackage{calrsfs}




\DeclareMathAlphabet{\pazocal}{OMS}{zplm}{m}{n}


\newcommand{\ling}{\pazocal{L}_{\Sigma}}
\newcommand{\lfium}{{\normalfont\textbf{LFI1}}}
\newcommand{\lfi}{{\normalfont\textbf{LFI}}}
\newcommand{\lfis}{{\normalfont\textbf{LFI}s}}
\newcommand{\meio}{\sfrac{1}{2}}
\newcommand{\conmat}{\vDash_{\pazocal{M}_{\lfium{}}}}
\newcommand{\conval}{\vDash_{\lfium{}}}
\newcommand{\conhil}{\vdash_{\lfium{}}}


\newcommand{\uglyphi}{\phi} % mantendo o \phi velho
\renewcommand \phi{\varphi}

\graphicspath{{Figuras/}}
\setbeamertemplate{frametitle continuation}{}

% suprimindo warnings do hyperref
\pdfstringdefDisableCommands{%
  \def\\{}%
  \def\texttt#1{#1}%
  \def\smallskip{}%
  \def\medskip{}%
}

\renewcommand{\figurename}{Figura}
\sloppy
\title[]{Implementação de uma biblioteca da Lógica de Inconsistência Formal LFI1 em Coq}

\author[Helena Vargas Tannuri]{
    Helena Vargas Tannuri\\\smallskip
    {\scriptsize Universidade do Estado de Santa Catarina \\\smallskip
    \vspace{-2mm}
    \texttt{helenavargastannuri@gmail.com}\\\medskip
    {Orientadora: Dra Karina Girardi Roggia}\\
    {Coorientador: Miguel Alfredo Nunes}
    }
}

\date{\today}

\begin{document}

    \begin{frame}
        \titlepage
    \end{frame}

    \begin{frame}[allowframebreaks]{Sumário}
        \tableofcontents
    \end{frame}

\section[]{Introdução}
    \begin{frame}{Introdução}
        \begin{itemize}
            \item Lógicas paraconsistentes são sistemas não-clássicos que separam a trivialidade da contradição;
            \begin{itemize}
                \item[--] Usualmente, lógicas ortodoxas assumem que toda teoria contraditória é uma teoria trivial, ou seja, uma teoria com todas as fórmulas.
            \end{itemize}
            \item Lógica não-clássica é qualquer lógica que quebra algum dos princípios da lógica clássica;
            \begin{itemize}
                \item[--] As lógicas paraconsistentes quebram o princípio da explosão (definido como $\alpha \to (\neg \alpha \to \beta)$)~\cite{carnielli2007}.
            \end{itemize}
            \item Lógicas de inconsistência formal (\lfis{}) são lógicas paraconsistentes que resgatam de maneira \textit{controlada} o princípio da explosão~\cite{Carnielli_Coniglio_2016}.
        \end{itemize}
    \end{frame}

    \begin{frame}{Introdução}
        \begin{itemize}
            \item Lógicas paraconsistentes, sobretudo \lfis{}, possuem diversas aplicações em diferentes campos do conhecimento;
            \begin{itemize}
                \item[--] Ciências naturais;
                \item[--] Linguística;
                \item[--] Computação (bancos de dados com inconsistências).
            \end{itemize}
            \item \lfium{}: Uma \lfi{} que internaliza o conceito de inconsistência dentro de sua linguagem (representado por $\circ$).
            \begin{itemize}
                \item[--] Resgata a explosividade com o princípio da explosão \textit{gentil} (definido como $\circ \alpha \to (\alpha \to (\neg \alpha \to \beta))$)~\cite{carnielli2000formal}.
            \end{itemize}
        \end{itemize}
    \end{frame}

    \begin{frame}{Introdução}
        \begin{itemize}
            \item Assistentes de provas são ferramentas de \textit{softwares} utilizadas no desenvolvimento de provas formais~\cite{Chlipala_2013};
            \item O Coq é um assistente de provas amplamente utilizado para a verificação formal de \textit{software} e para o desenvolvimento de teoremas, baseando-se no cálculo de construções indutivas~\cite{silva2019certificaccao};
            \item A implementação de uma biblioteca da \lfium{} em Coq permite provar metateoremas sobre esta lógica de maneira confiável, pois independe de um avaliador para garantir a correção destas provas;
            \item Análogo ao que foi desenvolvido em~\cite{silveira2020implementacao}.
        \end{itemize}
    \end{frame}

\section[]{Objetivos}
    \begin{frame}{Objetivo Geral}
        Implementar uma biblioteca de \lfium{} em Coq, assim como desenvolver os metateoremas da correção, da completude e da dedução dentro da biblioteca.
    \end{frame}

    \begin{frame}{Objetivos Específicos}
        \begin{enumerate}
			\item Estudar conceitos relevantes sobre lógicas paraconsistentes, em especial a \lfium{};
            \item Estudar e revisar as provas manuais para completude, correção e metateorema da dedução da \lfium{};
            \item Realizar um levantamento do estado da arte do desenvolvimento de lógicas paraconsistentes em assistentes de provas;
            \item Desenvolver uma biblioteca da \lfium{} em Coq, baseada na semântica e sintaxe previamente definidas;
            \item Desenvolver e verificar formalmente as provas para completude, correção e metateorema da dedução em Coq.
		\end{enumerate}
    \end{frame}

\section[]{Trabalhos Relacionados}
    \begin{frame}{Trabalhos Relacionados}
        \begin{enumerate}
            \item \citeauthoronline{Villadsen2017} (\citeyear{Villadsen2017}) implementam uma biblioteca de uma lógica paraconsistente com infinitos valores-verdade no assistente de provas Isabelle. Algumas metapropriedades são provadas dentro da biblioteca;
            \item \citeauthoronline{pdatalog} (\citeyear{pdatalog}) especificam uma linguagem de consulta a banco de dados baseada na lógica de inconsistência formal \lfium{}, chamada P{-}Datalog;
            \item \citeauthoronline{paralog} (\citeyear{paralog}) descrevem uma linguagem de programação lógica chamada ParaLog\_\textit{e}, que propõe mesclar conceitos de programação lógica clássica com conceitos de inconsistência, utilizando como base a lógica evidencial.
        \end{enumerate}
    \end{frame}

\section[]{Definições básicas}

    \begin{frame}{Definições básicas {-} Lógica Tarskiana}
        \setbool{@fleqn}{true}
        Uma lógica $\mathcal{L} = \langle \pazocal {L}, \Vdash \rangle$ que respeita estas propriedades é dita Tarskiana:
        \begin{align}
            \text{(i) } & \text{Se } \alpha \in \Gamma \text{ então } \Gamma \Vdash \alpha;\tag{reflexividade}                                                                                       \\
            \text{(ii) } & \text{Se } \Delta \Vdash \alpha \text{ e } \Delta \subseteq \Gamma \text{ então } \Gamma \Vdash \alpha;\tag{monotonicidade}                                                \\
            \text{(iii) } & \text{Se } \Delta \Vdash \alpha \text{ e } \Gamma \Vdash \delta \text{ para todo } \delta \in \Delta \text{ então } \Gamma \Vdash \alpha.\tag{corte}\\
            &\tag*\qed{}
        \end{align}
    \end{frame}

    \begin{frame}{Definições básicas {-} Lógica padrão}
        \setbool{@fleqn}{true}
        Uma lógica Tarskiana é dita \textit{padrão} caso ela respeite as seguintes condições:
        \begin{align*}
            & \text{~(i) Se } \Gamma \Vdash \alpha \text{, então } \sigma [\Gamma] \Vdash \sigma(\alpha) \text{, para toda substituição } \sigma \text{ de variável}\\&\text{por fórmula.}\\
            & \text{(ii) Se } \Gamma \Vdash \alpha \text{, então existe conjunto finito } \Gamma_{0} \subseteq \Gamma \text{ tal que } \Gamma_{0} \Vdash \alpha.\tag*\qed{}
        \end{align*}
    \end{frame}
    \begin{frame}{Definições básicas {-} Lógica paraconsistente}
        Uma lógica Tarskiana é dita \textit{paraconsistente} se ela possuir uma negação $\neg$ e existirem fórmulas quaisquer $\alpha, \beta \in \pazocal{L}$ tal que $\alpha, \neg \alpha \nVdash \beta$.\qed{}
    \end{frame}


    \begin{frame}{Definições básicas {-} \lfi{}}
       Uma lógica padrão será uma lógica de inconsistência formal (\lfi{}) (em relação a $\bigcirc(p)$ e $\neg$, onde $\bigcirc(p)$ é um conjunto não-vazio de fórmulas dependentes somente da variável $p$) caso respeite as seguintes condições:
        \begin{align*}
            \text{(i)} & \text{ Existem}~ \gamma, \delta \in \pazocal{L} \text{, de modo que } \gamma, \neg \gamma \nVdash \delta;               \\
            \text{(ii)} & \text{ Existem}~ \alpha, \beta \in \pazocal{L} \text{, de modo que:}                                                    \\
            & \qquad \text{(ii.a)}~ \bigcirc(\alpha), \alpha \nVdash \beta;                                                                         \\
            & \qquad \text{(ii.b)}~ \bigcirc(\alpha), \neg \alpha \nVdash \beta;                                                                    \\
            \text{(iii)} & \text{ Para todo}~ \phi, \psi \in \pazocal{L} \text{, tem-se } \bigcirc(\phi), \phi, \neg \phi \Vdash \psi. \tag*\qed{}
        \end{align*}
    \end{frame}

\section[]{\lfium{}}

    \begin{frame}{\lfium{} {-} Linguagem}
        Construção indutiva do menor conjunto $\ling{}$ que respeita:
        \begin{align*}
            & \text{1.~}\pazocal{P} \subseteq \ling{}                                                                                                                        \\
            & \text{2.~Se } \phi \in \ling{}, \text{então } \triangle  \phi \in \ling{}, \text{com } \triangle \in \{\neg, \circ\}                            \\
            & \text{3.~Se } \phi, \psi \in \ling{}, \text{então } \phi \otimes \psi \in \ling{}, \text{com } \otimes \in \{\land, \lor, \to\} \tag*\qed
        \end{align*}
    \end{frame}

    \begin{frame}{\lfium{} {-} Sintaxe}
        Cálculo de Hilbert $\conhil$, com 20 axiomas:
        \begin{align*}
            & \alpha \to (\beta \to \alpha)                                                     \tag{\textbf{Ax1}}            \label{ax:ax1}\\
            & (\alpha \to (\beta \to \gamma)) \to ((\alpha \to \beta) \to (\alpha \to \gamma )) \tag{\textbf{Ax2}}            \label{ax:ax2}\\
            & \alpha \to (\beta \to (\alpha \land \beta))                                       \tag{\textbf{Ax3}}            \label{ax:ax3}\\
            & (\alpha \land \beta) \to \alpha                                                   \tag{\textbf{Ax4}}            \label{ax:ax4}\\
            & (\alpha \land \beta) \to \beta                                                    \tag{\textbf{Ax5}}            \label{ax:ax5}\\
            & \alpha \to (\alpha \lor \beta)                                                    \tag{\textbf{Ax6}}            \label{ax:ax6}\\
            & \beta \to (\alpha \lor \beta)                                                     \tag{\textbf{Ax7}}            \label{ax:ax7}\\
            & (\alpha \to \gamma) \to ((\beta \to \gamma) \to ((\alpha \lor \beta) \to \gamma)) \tag{\textbf{Ax8}}            \label{ax:ax8}\\
            & (\alpha \to \beta) \lor \alpha                                                    \tag{\textbf{Ax9}}            \label{ax:ax9}\\
            & \alpha \lor \neg \alpha                                                           \tag{\textbf{Ax10}}           \label{ax:ax10}\\
    \end{align*}
    \end{frame}

    \begin{frame}{\lfium{} {-} Sintaxe}
        \begin{align*}
            & \circ \alpha \to (\alpha \to (\neg \alpha \to \beta))                             \tag{\textbf{bc1}}            \label{ax:axbc1}\\
            & \neg \neg \alpha \to \alpha                                                       \tag{\textbf{cf}}             \label{ax:axcf}\\
            & \alpha \to \neg \neg \alpha                                                       \tag{\textbf{ce}}             \label{ax:axce}\\
            & \neg \circ \alpha \to (\alpha \land \neg \alpha)                                  \tag{\textbf{ci}}             \label{ax:axci}\\
            & \neg (\alpha \lor \beta) \to (\neg \alpha \land \neg \beta)                       \tag{\textbf{neg}$\lor_{1}$}  \label{ax:axneglor1}\\
            & (\neg \alpha \land \neg \beta) \to \neg (\alpha \lor \beta)                       \tag{\textbf{neg}$\lor_{2}$}  \label{ax:axneglor2}\\
            & \neg(\alpha \land \beta) \to (\neg \alpha \lor \neg \beta)                        \tag{\textbf{neg}$\land_{1}$} \label{ax:axnegland1}\\
            & (\neg \alpha \lor \neg \beta) \to \neg (\alpha \land \beta)                       \tag{\textbf{neg}$\land_{2}$} \label{ax:axnegland2}\\
            & \neg (\alpha \to \beta) \to(\alpha \land \neg \beta)                              \tag{\textbf{neg}$\to_{1}$}   \label{ax:axnegto1}\\
            & (\alpha \land \neg \beta) \to \neg(\alpha \to \beta)                              \tag{\textbf{neg}$\to_{2}$}   \label{ax:axnegto2}\\
        \end{align*}
    \end{frame}

    \begin{frame}{\lfium{} {-} Sintaxe}
        \centering
        Regra de inferência \textit{modus ponens}:
        \begin{prooftree}
            \AxiomC{$\alpha$}
            \AxiomC{$\alpha \to \beta$}
            \RightLabel{MP}
            \BinaryInfC{$\beta$}
        \end{prooftree}
        \qed{}
    \end{frame}

    \begin{frame}{\lfium{} {-} Semântica}
        A \lfium{} possui dois sistemas semânticos:
        \begin{itemize}
            \item Semântica matricial;
            \begin{itemize}
                \item [-] Trivalorada;
                \item [-] Algébrica.
            \end{itemize}
            \item Semântica de valorações.
            \begin{itemize}
                \item [-] Bivalorada;
                \item [-] Não-determinística.
            \end{itemize}
        \end{itemize}
    \end{frame}

    \begin{frame}{\lfium{} {-} Semântica matricial}
        $\pazocal{M}_{\lfium{}} = \langle M, D, O \rangle$, com $M = \{1, \meio{}, 0\}$ e $D = \{1, \meio{}\}$.
        \noindent
        \begin{minipage}{0.3\textwidth}
            % Implication (→)
            \[
                \begin{array}{c|ccc} %chktex 44%chktex 44
                    \to & 1 & \meio{} & 0 \\
                    \hline%chktex 44
                    1           & 1 & \meio{} & 0 \\
                    \meio{} & 1 & \meio{} & 0 \\
                    0           & 1 & 1           & 1 \\
                \end{array}
            \]
        \end{minipage}
        \begin{minipage}{0.3\textwidth}
            % Conjunction (∧)
            \[
                \begin{array}{c|ccc} %chktex 44%chktex 44
                    \land       & 1           & \meio{} & 0 \\
                    \hline%chktex 44
                    1           & 1           & \meio{} & 0 \\
                    \meio{} & \meio{} & \meio{} & 0 \\
                    0           & 0           & 0           & 0 \\
                \end{array}
            \]
        \end{minipage}
        \begin{minipage}{0.3\textwidth}
            % Disjunction (∨)
            \[
                \begin{array}{c|ccc} %chktex 44%chktex 44
                    \lor        & 1 & \meio{} & 0           \\
                    \hline%chktex 44
                    1           & 1 & 1           & 1           \\
                    \meio{} & 1 & \meio{} & \meio{} \\
                    0           & 1 & \meio{} & 0           \\
                \end{array}
            \]
        \end{minipage}

        \vspace{0.5cm}

        \begin{minipage}{0.5\textwidth}
            % Negation (¬)
            \[
                \begin{array}{c|c}%chktex 44
                                & \neg        \\
                    \hline%chktex 44
                    1           & 0           \\
                    \meio{} & \meio{} \\
                    0           & 1           \\
                \end{array}
            \]
        \end{minipage}
        \begin{minipage}{0.3\textwidth}
            \[
                \begin{array}{c|c}%chktex 44
                                & \circ   \\
                    \hline%chktex 44
                    1           & 1         \\
                    \meio{} & 0         \\
                    0           & 1         \\
                \end{array}
            \]
        \end{minipage}

        $\Gamma \conmat \phi$ sse, para toda valoração $h : \ling{} \to M$ de $\pazocal{M}_{\lfium{}}$, se $h[\Gamma] \subseteq D$ então $h(\phi) \in D$.\qed{}
    \end{frame}

    \begin{frame}{\lfium{} {-} Semântica de valorações}
        Uma função $v : \ling{} \to \{1, 0\}$ é uma valoração para a lógica \lfium{} caso ela satisfaça as seguintes cláusulas:
            \begin{align*}
                & v(\alpha \land \beta) = 1 \Longleftrightarrow v(\alpha) = 1 \text{ e } v(\beta) = 1\tag{\textbf{$vAnd$}}\label{val:vand}\\
                & v(\alpha \lor \beta) = 1 \Longleftrightarrow v(\alpha) = 1 \text{ ou } v(\beta) = 1\tag{\textbf{$vOr$}}\label{val:vor}\\
                & v(\alpha \to \beta) = 1 \Longleftrightarrow v(\alpha) = 0 \text{ ou } v(\beta) = 1\tag{\textbf{$vImp$}}\label{val:vimp}\\
                & v(\neg \alpha) = 0 \Longrightarrow v(\alpha) = 1\tag{\textbf{$vNeg$}}\label{val:vneg}\\
                & v(\circ \alpha) = 1 \Longrightarrow v(\alpha) = 0 \text{ ou } v(\neg \alpha) = 0\tag{\textbf{$vCon$}}\label{val:vcon}\\
                & v(\neg \circ \alpha) = 1 \Longrightarrow v(\alpha) = 1 \text{ e } v(\neg \alpha) = 1\tag{\textbf{$vCi$}}\label{val:vci}\\
                & v(\neg \neg \alpha) = 1 \Longleftrightarrow v(\alpha) = 1\tag{\textbf{$vDNE$}}\label{val:vdne}\\
                & v(\neg (\alpha \land \beta)) = 1 \Longleftrightarrow v(\neg \alpha) = 1 \text{ ou } v(\neg \beta) = 1\tag{\textbf{$vDM_{\land}$}}\label{val:vdmand}\\
                & v(\neg (\alpha \lor \beta)) = 1 \Longleftrightarrow v(\neg \alpha) = 1 \text{ e } v(\neg \beta) = 1\tag{\textbf{$vDM_{\lor}$}}\label{val:vdmor}\\
                & v(\neg (\alpha \to \beta)) = 1 \Longleftrightarrow v(\alpha) = 1 \text{ e } v(\neg \beta) = 1\tag{\textbf{$vCip_{\to}$}}\label{val:vcip}
            \end{align*}
            $\Gamma \conval \phi$ sse, para toda valoração $v$ de \lfium{}, se $v[\Gamma] \subseteq \{1\}$ então $v(\phi) = 1$.\qed{}
    \end{frame}

\section[]{Metateoremas}

\section[]{Conclusões}
    \begin{frame}{Conclusões}
        \begin{itemize}
            \item Uma implementação paramétrica de fusão de sistemas sintáticos semelhante a desenvolvida nesse trabalho não foi encontrado nos trabalhos relacionados;
            \item Não foi possível terminar a implementação da fusão de sistemas semânticos devido a escolhas de implementação da biblioteca base;
            \item Não foi possível demonstrar transferência de propriedades no Coq.%Demonstrar transferência de propriedades no Coq se mostrou estar além do escopo deste trabalho.
        \end{itemize}
    \end{frame}

    \section[]{Referências}
    \begin{frame}[allowframebreaks]{Referências}
        \bibliography{referencias}
    \end{frame}

\end{document}